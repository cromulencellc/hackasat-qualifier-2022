import malleability
import socket 
import hmac
import binascii 
from Crypto.Cipher import AES
def replace_block( data , block_to_replace , replace_with ):
    blocks = malleability.text_to_block( data , AES.block_size )
    blocks[block_to_replace] = blocks[replace_with]
    return b"".join( blocks )
class BitStreamPwner:
    def __init__( self , bitstream_file , ip ,port ):
        # open the bit file
        f = open( bitstream_file , 'rb')
        self.bitstream = f.read()
        f.close()    
        #
        self.header = self.bitstream[:20]
        self.footer = self.bitstream[-16:]
        self.encrypted = self.bitstream[20:-16]
        self.n_blocks = int(len(self.encrypted)/AES.block_size)
        #
        self.bit_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.bit_socket.connect((ip, port)) 
    def send_og( self ):
        print( "Sending unmodified bitstream ....just for fun")
        self.bit_socket.send( self.bitstream )
    def decrypt( self , start_byte,  known_text):
        print("Using starbleed to leak the bitstream")
        self.known = known_text
        self.known_byte = start_byte
        num_words = int(len(self.encrypted)/4) -4
        decrypted = bytearray(b'')
        print(num_words)
        for k in range(num_words):
            word = self.starbleed( k )
            decrypted.extend( word )
            input("continue?")
        self.decrypted = decrypted
        f = open('decrypted.bit','wb')
        f.write(self.header)
        f.write(decrypted)
        f.write(self.footer)
        f.close()
        print("decryption complete")
    def forge_bitstream( self , filename  ):
        # make the decrypted section
        decryted_section = bytearray(b'')
        # Add the hmac key
        hmac_key = "AnyHmacKeyWorks!".encode('utf-8')
        decryted_section.extend(hmac_key)
        # Add the configuration command - write 4 bytes as zero to cfg
        cfg = b'\x01\x01\x00\x04file'
        decryted_section.extend( cfg )
        # Add the write nvmem command
        nv_data = '{"print_flag":200}'
        L = len(nv_data)
        nvwr = b'\x01\x03'
        nv_len = L.to_bytes( 2 , byteorder="big")
        decryted_section.extend( nvwr )
        decryted_section.extend( nv_len )
        decryted_section.extend( nv_data.encode('utf-8'))
        # Calculate and append the hmac tag
        L = len( decryted_section ) 
        n_pad = AES.block_size - (L%AES.block_size)
        # pad with noops
        pad = b"\x11" * n_pad
        decryted_section.extend( pad )
        keygen =  hmac.new(hmac_key, msg = decryted_section[len(hmac_key):] , digestmod='sha256')
        tag = keygen.hexdigest()
        tag_binary = binascii.unhexlify(tag)
        decryted_section.extend(tag_binary)
        # 
        pwnt = self.encrypt( decryted_section )
        
        # Write the file
        f = open(filename,'wb')
        # Header
        f.write("HAS3FABIC-SECURE".encode('utf-8'))
        # Encryption start 
        f.write(b"\xc0\xff\xee!")
        # Write encrypted data
        f.write(pwnt)
        # Footer 
        f.write( "HAS3-TAG--SECURE".encode('utf-8'))
        f.close()
    def encrypt( self , data  ):
        # Using starbleed to encrypt stuff
        cbc = malleability.CbcEncryptExploit( data )
        N = int(len(data)/AES.block_size)
        data_encrypted = bytearray( b'' ) 
        # We need to initialize the decryption with any known cypher plaintext pair - everythng after this is totally arbitrrary!!!!
        arbirtray_block = "ThisIsArbitrary!".encode('utf-8')
        Ci = "EvenMorArbitrary".encode('utf-8')
        data_encrypted = Ci + data_encrypted # still need this ya?
        blocks = malleability.text_to_block( self.encrypted , AES.block_size)
        for k in range( N,0,-1 ):
            self.encrypted = b"".join( blocks )
            # Decrypt a whole block using starbleed
            Pi = self.decrypt_oracle( Ci  , arbirtray_block)

            Ci_m1 = cbc.attack(  Pi , arbirtray_block  )
            # Patch this on the FRONT
            data_encrypted = Ci_m1 + data_encrypted
            Ci = Ci_m1
        return data_encrypted
    def decrypt_oracle( self , Ci  , arbitrary_block):
        blocks = malleability.text_to_block( self.encrypted , AES.block_size)

        attack_block = len(blocks)-1
        blocks[ attack_block ] = Ci 
        blocks[ attack_block-1 ] = arbitrary_block
        self.encrypted = b"".join( blocks )

        decrypted = bytearray(b'')
        for z in range(4):
            # We're always attacking block 0
            attack_word = ((attack_block-1) *4) + z
            o = self.starbleed( attack_word )
            decrypted.extend( o )
        out = bytes( decrypted )
        #
        return out
    def send_bitstream( self , filename ):
        f = open(filename,'rb')
        out = f.read()
        f.close()
        input("send??")
        self.bit_socket.send( out )
    def starbleed(self , word_number ):
        # PWN the bitstream file to "write" to a register we know about
        # write 12 bytes such that the last 4 bytes are in the next block
        encrypted_data = self.encrypted
        word_byte_num = word_number*4 
        word_block = int(word_byte_num/AES.block_size)+1 
        word_in_block = int( ((word_number/4)%1)*4 )
        write_len = (self.n_blocks-3)*AES.block_size + word_in_block*4
        malicious_write = bytearray(b'\x01\x07\x00')
        malicious_write.extend( write_len.to_bytes(1,byteorder="big") )
        malicious = bytes( malicious_write )
        # Move the block we want decrypted into the right position
        encrypted_data = replace_block( encrypted_data , self.n_blocks-2 ,  word_block-1)
        encrypted_data = replace_block( encrypted_data , self.n_blocks-1 ,  word_block)

        cbc = malleability.CbcDecrypExploit(encrypted_data)
        out = cbc.decryption_attack( self.known_byte , known_plaintext=self.known,malicious_plaintext=malicious)
        wr_bit_stream = bytearray(b'')
        wr_bit_stream.extend( self.header )
        wr_bit_stream.extend( out )
        wr_bit_stream.extend( self.footer)
        self.bit_socket.send( wr_bit_stream )
        input("continue?")
        # PWN the bitstream to "read" from the register we know about
        # Create a malicious read that is 1 read of RESERVED_1 and two no-ops
        malicious_read = b'\x10\x07\x11\x11' 
        encrypted_data = self.encrypted
        cbc2 = malleability.CbcDecrypExploit(encrypted_data)
        out = cbc2.decryption_attack( self.known_byte ,self.known,  malicious_read )

        rd_bit_stream = bytearray(b'')
        rd_bit_stream.extend( self.header)
        rd_bit_stream.extend( out )
        rd_bit_stream.extend( self.footer)
        self.bit_socket.send( rd_bit_stream )
        bleed = self.bit_socket.recv(1000)
        print("The following word was output as a result of starbleed")
        print(bleed)
        return bleed

def run( file , ip , port ):
    pwner = BitStreamPwner( file , ip , port )
    known = b'\x01\x01\x00\x04' 
    known_byte = 32
    print("Decrypting without the keys")
    pwner.decrypt( known_byte,known )
    print("Encrypting a new bitstream without the keys")
    pwner.forge_bitstream( "flag_printer.bit" )
    print("Using the new bitstream to get my flag!")
    pwner.send_bitstream("flag_printer.bit")
    input("Done?")
    input("Done?")


if __name__ == "__main__":
    file = "../data/secure.bit"
    port = 5000
    ip = "127.0.0.1"
    run( file , ip , port )